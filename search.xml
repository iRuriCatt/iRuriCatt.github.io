<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git</title>
    <url>/2024/08/22/git/</url>
    <content><![CDATA[<h1 id="一-git-基础"><a class="anchor" href="#一-git-基础">#</a> 一. git 基础</h1>
<h2 id="1-什么是-git"><a class="anchor" href="#1-什么是-git">#</a> 1. 什么是 git？</h2>
<blockquote>
<ul>
<li>Git 是一个免费开源的分布式版本控制系统，它使用一个特殊的名为仓库的数据库来记录文件的变化</li>
<li>仓库中的每个文件都有一个完整的版本历史记录，可以看到谁在什么时间修改了哪些文件的哪些内容，在需要时也可以将文件恢复到之前的某个版本</li>
<li>有了版本控制系统，我们就可以跟踪每个文件的变化，让项目成员之间的协作更加高效</li>
<li>目前世界上最流行的版本控制系统有两种
<ul>
<li>集中式版本控制系统，如 SVN、CVS 等</li>
<li>分布式版本控制系统，如 Git、Mercurial 等</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="11-集中式版本控制系统"><a class="anchor" href="#11-集中式版本控制系统">#</a> 1.1 集中式版本控制系统</h3>
<ul>
<li>工作流程
<ul>
<li>所有文件都保存在中央服务器上，每个人的电脑上只保存了一个副本</li>
<li>当需要修改文件时，要先从中央服务器上下载最新的版本，然后再添加想要的修改内容，修改完成后再上传回中央服务器</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240814120734843.png" alt="image-20240814120734843"></p>
<ul>
<li>
<p>优点</p>
<ul>
<li>使用简单，只需要从中央服务器上下载最新的版本，修改完成后再上传到中央服务器上即可，不需要考虑其他问题</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>中央服务器的单点故障问题：如果中央服务器出现故障或者网络连接出现问题，那么所有人都无法工作了，只能等待中央服务器或者网络恢复正常</li>
</ul>
</li>
</ul>
<h3 id="12-分布式版本控制系统"><a class="anchor" href="#12-分布式版本控制系统">#</a> 1.2 分布式版本控制系统</h3>
<ul>
<li>工作流程
<ul>
<li>每个人的电脑上都有一个完整的版本库，因此可以在本地进行修改，不需要考虑网络问题，即使中央服务器出现故障，也可以继续工作</li>
<li>当需要将修改内容分享给其他人时，只需要将仓库互相同步一下即可</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240814121426834.png" alt="image-20240814121426834"></p>
<h2 id="2-git-的初始化配置"><a class="anchor" href="#2-git-的初始化配置">#</a> 2. Git 的初始化配置</h2>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span>			配置用户名</span><br><span class="line">git config --global user.email <span class="string">&quot;mail@example.com&quot;</span>	配置邮箱</span><br><span class="line">git config --global credential.helper store			存储配置</span><br><span class="line">git config --global --list							查看配置信息</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注：
<ul>
<li>省略（Local）：本地配置，只对本地仓库有效</li>
<li><code>--global</code> ：全局配置，所以仓库生效</li>
<li><code>--system</code> ：系统配置，对所有用户生效</li>
</ul>
</li>
</ul>
<h2 id="3-新建版本库仓库"><a class="anchor" href="#3-新建版本库仓库">#</a> 3. 新建版本库（仓库）</h2>
<blockquote>
<p>版本库又叫仓库（Repository，简称 Repo），可以将仓库理解成一个目录，这个目录里面所有的文件都可以被 Git 管理起来，每个文件的修改、删除、添加等操作，Git 都能跟踪到，以便任何时候都可以追踪历史或者还原到之前的某一个版本</p>
</blockquote>
<ul>
<li>
<p>创建一个仓库非常简单，只需要将一个目录变成 Git 可以管理的仓库即可</p>
</li>
<li>
<p>一般来说，可以通过两种方式创建仓库</p>
<ul>
<li><code>git init &lt;project-name&gt;</code> ：在自己电脑本地直接创建一个仓库（省略 project-name 则在当前目录创建）</li>
<li><code>git clone &lt;url&gt;</code> ：从远程服务器上克隆一个已经存在的仓库</li>
</ul>
</li>
<li>
<p>创建本地仓库</p>
</li>
</ul>
<p><img data-src="git/image-20240816230748069.png" alt="image-20240816230748069"></p>
<p><img data-src="git/image-20240816231007617.png" alt="image-20240816231007617"></p>
<p><img data-src="git/image-20240816231535609.png" alt="image-20240816231535609"></p>
<ul>
<li>
<p><code>.gti</code>  这个目录存放了 Git 仓库的所有数据</p>
</li>
<li>
<p><code>.git</code>  中的文件和目录都是 Git 仓库的重要组成部分，不能随意删除或者修改这些文件的内容，否则会破坏 Git 仓库</p>
</li>
<li>
<p>克隆远程仓库</p>
</li>
</ul>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/geekhall-laoyang/remote-repo.git</span><br></pre></td></tr></table></figure></p>
<p><img data-src="git/image-20240816232500401.png" alt="image-20240816232500401"></p>
<h2 id="4-git-的工作区域和文件状态"><a class="anchor" href="#4-git-的工作区域和文件状态">#</a> 4. Git 的工作区域和文件状态</h2>
<h3 id="41-git-的工作区域"><a class="anchor" href="#41-git-的工作区域">#</a> 4.1 Git 的工作区域</h3>
<ul>
<li>
<p>Git 的本地数据管理分为三个区域，分别是工作区、暂存区、本地仓库</p>
</li>
<li>
<p>工作区（Working Directory）：电脑里能实际看到的目录</p>
</li>
<li>
<p>暂存区（Staging Area）：也叫索引，用来临时存放未提交的内容，一般在 .git 目录下的 index 中</p>
</li>
<li>
<p>本地仓库（Local Repository）：Git 在本地的版本库，它包含了完整的项目历史和元数据，是 Git 存储代码和版本信息的主要位置，仓库信息存储在.git 这个隐藏目录中</p>
</li>
<li>
<p>远程仓库（Remote Repository）：托管在远程服务器上的仓库。常用的有 GitHub、GitLab、Gitee</p>
</li>
<li>
<p>简单来说</p>
<ul>
<li>工作区是实际操作的目录，暂存区是中间区域，用于临时存放即将提交的修改内容，本地仓库是 Git 存储代码和版本信息的主要位置</li>
</ul>
</li>
<li>
<p>流程</p>
<ul>
<li>当修改完工作区的文件后，需要将它们添加到暂存区，然后再将暂存区的修改提交到本地仓库中</li>
</ul>
</li>
<li>
<p>该过程可以使用 Git 提供的命令来查看、比较或者撤销修改内容，来保证版本控制的准确性和完整性</p>
</li>
</ul>
<p><img data-src="git/image-20240816233625951.png" alt="image-20240816233625951"></p>
<h3 id="42-文件状态"><a class="anchor" href="#42-文件状态">#</a> 4.2 文件状态</h3>
<table>
<thead>
<tr>
<th>文件状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>未跟踪（Untrack）</td>
<td>新创建的还没有被 Git 管理起来的文件</td>
</tr>
<tr>
<td>未修改（Unmodified）</td>
<td>已经被 Git 管理起来，但是文件的内容没有发生变化，还没有被修改过</td>
</tr>
<tr>
<td>已修改（Modified）</td>
<td>已经修改了的文件，但是还没有添加到暂存区里面</td>
</tr>
<tr>
<td>已暂存（Staged）</td>
<td>修改后并且已经添加到了暂存区域内的文件</td>
</tr>
<tr>
<td>已提交（Committed）</td>
<td>把暂存区的文件提交到本地仓库后的状态</td>
</tr>
</tbody>
</table>
<p><img data-src="git/image-20240816234201934.png" alt="image-20240816234201934"></p>
<h2 id="5-添加和提交文件"><a class="anchor" href="#5-添加和提交文件">#</a> 5. 添加和提交文件</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git status</code></td>
<td>查看仓库的状态，列出还未提交的新的或修改的文件</td>
</tr>
<tr>
<td><code>git log</code> &lt;br /&gt; <code>git log --oneline</code></td>
<td>查看提交记录 &lt;br /&gt; 使用 <code>--oneline</code>  参数查看简洁的提交记录</td>
</tr>
<tr>
<td><code>git add</code></td>
<td>将文件添加到暂存区，等待后续的提交操作 &lt;br /&gt; 可以使用通配符，如： <code>git add *.txt</code> &lt;br /&gt; 可以使用目录，如： <code>git add .</code></td>
</tr>
<tr>
<td><code>git commit -m &quot;提交的信息&quot;</code></td>
<td>将文件提交到仓库中（只会提交暂存区中的文件）&lt;br /&gt; 如果不指定 - m，则会进入交互模式（默认使用 vim 进行编辑）</td>
</tr>
</tbody>
</table>
<ul>
<li>创建文件，查看文件状态</li>
</ul>
<p><img data-src="git/image-20240817000813475.png" alt="image-20240817000813475"></p>
<ul>
<li>将文件添加到暂存区
<ul>
<li><code>git rm --cache &lt;file&gt;</code> ：可以取消暂存</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817001518557.png" alt="image-20240817001518557"></p>
<ul>
<li>将暂存区中的文件提交到仓库中</li>
</ul>
<p><img data-src="git/image-20240817002327619.png" alt="image-20240817002327619"></p>
<ul>
<li><code>git add</code>  还可以使用通配符来添加多个文件
<ul>
<li>示例： <code>git add *.txt</code></li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817002727517.png" alt="image-20240817002727517"></p>
<ul>
<li><code>git add</code>  还可以接受文件夹作为参数
<ul>
<li>比如想要添加所有文件的话，使用 <code>git add .</code> （这里的点表示当前目录）</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817003134519.png" alt="image-20240817003134519"></p>
<ul>
<li><code>git log</code> ：查看提交记录</li>
</ul>
<p><img data-src="git/image-20240817003328784.png" alt="image-20240817003328784"></p>
<ul>
<li><code>git log --oneline</code> ：查看简洁的提交记录</li>
</ul>
<p><img data-src="git/image-20240817003445556.png" alt="image-20240817003445556"></p>
<h2 id="6-回退版本"><a class="anchor" href="#6-回退版本">#</a> 6. 回退版本</h2>
<blockquote>
<p>reset 命令用于回退版本，可以退回到之前的某一个提交的状态</p>
</blockquote>
<ul>
<li>语法格式</li>
</ul>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --mixed &lt;commit-id&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>三种模式</li>
</ul>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft	表示回退到某一个版本，并且保留工作区和暂存区的所有修改内容</span><br><span class="line">git reset --hard	表示回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容</span><br><span class="line">git reset --mixed	表示回退到某一个版本，并且只保留工作区的修改内容，丢弃暂存区的修改内容</span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>mixed 是 reset 命令的默认参数</p>
</li>
<li>
<p>示例</p>
<ul>
<li>创建三个文件，并依次提交</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817133414055.png" alt="image-20240817133414055"></p>
<ul>
<li><code>--soft</code></li>
</ul>
<p><img data-src="git/image-20240817133502744.png" alt="image-20240817133502744"></p>
<ul>
<li>查看工作区的内容：file3.txt 文件还在</li>
</ul>
<p><img data-src="git/image-20240817133701257.png" alt="image-20240817133701257"></p>
<ul>
<li>查看暂存区的内容</li>
</ul>
<p><img data-src="git/image-20240817134228875.png" alt="image-20240817134228875"></p>
<ul>
<li><code>git status</code></li>
</ul>
<p><img data-src="git/image-20240817134350787.png" alt="image-20240817134350787"></p>
<ul>
<li><code>--hard</code></li>
</ul>
<p><img data-src="git/image-20240817134838576.png" alt="image-20240817134838576"></p>
<ul>
<li><code>--mixed</code></li>
</ul>
<p><img data-src="git/image-20240817135314990.png" alt="image-20240817135314990"></p>
<ul>
<li>
<p>一般来说，当连续提交了多个版本，但又觉得这些提交没有太大意义，可以合并成一个版本时，便可以通过 <code>--soft</code>  和 <code>--mixed</code>  这两个参数来进行回退后重新提交</p>
</li>
<li>
<p>这两个参数的主要区别是：在重新提交之前， <code>--mixed</code>  需要执行一下 <code>git add</code>  操作来将变动的内容重新添加到暂存区，而 <code>--soft</code>  则不需要，因为暂存区没有被清空</p>
</li>
<li>
<p><code>--hard</code>  的使用场景：真的要放弃目前本地的所有修改内容（谨慎使用）</p>
</li>
<li>
<p>如果出现了失误操作也没关系，Git 中的所有操作都是可以回溯的，可以使用 <code>git reflog</code>  命令来查看操作的历史记录，然后找到误操作之前的版本号，再使用 <code>git reset</code>  命令来回退到该版本即可</p>
</li>
</ul>
<p><img data-src="git/image-20240817140337270.png" alt="image-20240817140337270"></p>
<h2 id="7-查看差异"><a class="anchor" href="#7-查看差异">#</a> 7. 查看差异</h2>
<p><img data-src="git/image-20240817140515468.png" alt="image-20240817140515468"></p>
<ul>
<li>语法格式</li>
<li><code>git diff</code>
<ul>
<li>默认比较的是工作区和暂存区之间的差异内容（因为修改后还没提交到暂存区），会显示发生更改的文件以及更改的详细信息</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817141148674.png" alt="image-20240817141148674"></p>
<ul>
<li><code>git diff HEAD</code>
<ul>
<li>比较工作区和版本库之间的差异（添加的内容还没有被提交到仓库中）</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817141346029.png" alt="image-20240817141346029"></p>
<ul>
<li><code>git diff --cached</code>
<ul>
<li>比较暂存区和版本库之间的差异</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817141603317.png" alt="image-20240817141603317"></p>
<ul>
<li><code>git diff &lt;commit-id&gt; &lt;commit-id&gt;</code>
<ul>
<li>查看两个提交之间的差异</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817141913396.png" alt="image-20240817141913396"></p>
<ul>
<li>
<p><code>git diff 39ab5d2 HEAD</code></p>
<ul>
<li><code>HEAD</code> ：指向分支的最新提交节点</li>
<li><code>HEAD~ / HEAD^</code> ：表示上一个版本</li>
<li><code>HEAD~数字</code> ：表示提交之前的第 n 个版本</li>
</ul>
</li>
<li>
<p><code>git diff HEAD~3 HEAD file3.txt</code></p>
<ul>
<li>表示只查看文件 file3.txt 的差异</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817143441186.png" alt="image-20240817143441186"></p>
<ul>
<li><code>git diff 分支1 分支2</code>
<ul>
<li>查看两个分支之间的差异，直接加上两个分支名即可</li>
</ul>
</li>
</ul>
<h2 id="8-删除文件"><a class="anchor" href="#8-删除文件">#</a> 8. 删除文件</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rm file</code> &lt;br /&gt; <code>git add file</code></td>
<td>先从工作区删除文件，然后再暂存删除内容</td>
</tr>
<tr>
<td><code>git rm &lt;file&gt;</code></td>
<td>把文件从工作区和暂存区同时删除</td>
</tr>
<tr>
<td><code>git rm --cached &lt;file&gt;</code></td>
<td>把文件从暂存区删除，但保留在当前工作区中</td>
</tr>
<tr>
<td><code>git rm -r *</code></td>
<td>递归删除某个目录下的所有子目录和文件</td>
</tr>
</tbody>
</table>
<ul>
<li>删除后记得提交！</li>
</ul>
<h2 id="9-gitignore忽略文件"><a class="anchor" href="#9-gitignore忽略文件">#</a> 9.  <code>.gitignore</code>  忽略文件</h2>
<blockquote>
<p>这个文件的作用就是可以忽略掉一些不应该被加入到版本库中的文件，这样可以让仓库体积更小、更加干净</p>
</blockquote>
<ul>
<li>
<p>应该忽略哪些文件？</p>
<ul>
<li>系统或软件自动生成的文件，比如一些工具或软件产生的临时文件</li>
<li>编译生成的中间文件、可执行文件等</li>
<li>运行过程中生成的日志文件、缓存文件、临时文件</li>
<li>设计身份、密码、口令、秘钥等敏感信息文件</li>
</ul>
</li>
<li>
<p>可以在这个文件中列出需要忽略的文件的模式，这样这些文件就不会被添加到版本库</p>
</li>
</ul>
<p><img data-src="git/image-20240817145012147.png" alt="image-20240817145012147"></p>
<ul>
<li>创建两个日志文件</li>
</ul>
<p><img data-src="git/image-20240817145553025.png" alt="image-20240817145553025"></p>
<ul>
<li>将 access.log 添加到 .gitignore 中</li>
</ul>
<p><img data-src="git/image-20240817145718133.png" alt="image-20240817145718133"></p>
<ul>
<li>提交文件后，access.log 并没有被提交到版本库中</li>
</ul>
<p><img data-src="git/image-20240817145814552.png" alt="image-20240817145814552"></p>
<ul>
<li>
<p><code>.gitignore</code>  文件生效的前提是：文件不能是已经被添加到版本库中的文件</p>
</li>
<li>
<p><code>*.log</code>  写入文件中，忽略所有日志文件</p>
</li>
<li>
<p>PS：空文件夹是不会被 git 管理起来的</p>
</li>
<li>
<p>添加要忽略的文件夹： <code>temp/</code></p>
</li>
</ul>
<p><img data-src="git/image-20240817150654015.png" alt="image-20240817150654015"></p>
<ul>
<li>查看仓库状态： <code>git status -s</code>
<ul>
<li>M 表示文件被修改过</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817151224013.png" alt="image-20240817151224013"></p>
<ul>
<li>提交文件 <code>git commit -am &quot;test ignore folder&quot;</code>
<ul>
<li>temp 文件没有被提交到仓库中</li>
<li><code>-am</code>  指添加到暂存和提交这两步操作合为一步</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240817151338011.png" alt="image-20240817151338011"></p>
<ul>
<li>
<p><code>.gitignore</code>  文件的匹配规则</p>
<ul>
<li>从上到下逐行匹配，每一行表示一个忽略模式</li>
<li>空行或者以 <code>#</code> 开头的行会被 Git 忽略。一般空行用于可读性的分隔， <code>#</code> 一般用作注释</li>
<li>使用标准的 Blob 模式匹配（指 shell 所使用的简化了的正则表达式）
<ul>
<li><code>*</code>  通配任意个字符</li>
<li><code>?</code>  匹配单个字符</li>
<li><code>[]</code>  表示匹配列表中的单个字符，比如：[abc] 表示 a/b/c</li>
</ul>
</li>
<li><code>**</code>  表示匹配任意的中间目录</li>
<li>中括号可以使用短中线连接，比如
<ul>
<li><code>[0-9]</code>  表示任意一位数字， <code>[a-z]</code>  表示任意一位小写字母</li>
</ul>
</li>
<li><code>!</code>  表示取反
<ul>
<li>要忽略指定模式以外的文件或者目录，取反即可</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略所有的.a文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但跟踪所有的lib.a，即便你在前面忽略了.a文件</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的TODO文件，而不忽略子目录下的/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略任何目录下名为build的文件夹</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略doc/notes.txt，但不忽略doc/server/arch.txt（doc子目录下面的txt文件）</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略doc/目录及其所有子目录下的.pdf文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure></p>
<ul>
<li>GitHub 上提供了各种常用语言的忽略文件的模板，在新建仓库时可以直接使用，也可以根据自己需要进行修改</li>
</ul>
<h2 id="10-远程仓库"><a class="anchor" href="#10-远程仓库">#</a> 10. 远程仓库</h2>
<h3 id="101-github-gitee"><a class="anchor" href="#101-github-gitee">#</a> 10.1 GitHub / Gitee</h3>
<h4 id="1011-ssh配置"><a class="anchor" href="#1011-ssh配置">#</a> 10.1.1 SSH 配置</h4>
<ul>
<li>生成 SSH 秘钥
<ul>
<li>输入密钥名称（如果是第一次生成，则直接回车，如果是已经配置过 SSH 密钥了，则需要指定新的名称，如 test）</li>
</ul>
</li>
</ul>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure></p>
<p><img data-src="git/image-20240817163839137.png" alt="image-20240817163839137"></p>
<ul>
<li>复制公钥信息到 GitHub 上</li>
</ul>
<p><img data-src="git/image-20240817164208138.png" alt="image-20240817164208138"></p>
<ul>
<li>如果是指定了新的文件名，需要增加一步新的配置，将以下内容写入 config 文件
<ul>
<li><code>tail -5 config</code> ：查看 config 文件最后 5 行内容</li>
<li>这个配置文件的意思是：当访问 GitHub 时，指定使用 SSH 下的 test 这个秘钥</li>
</ul>
</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/test</span><br></pre></td></tr></table></figure></p>
<h4 id="1012-克隆远程仓库"><a class="anchor" href="#1012-克隆远程仓库">#</a> 10.1.2 克隆远程仓库</h4>
<ul>
<li>生成好 SSH 秘钥之后，回到本地仓库执行 <code>git clone</code>  命令</li>
<li>Tips：如果创建秘钥的时候没有输入密码，则可以直接回车</li>
</ul>
<p><img data-src="git/image-20240819140745119.png" alt="image-20240819140745119"></p>
<ul>
<li>
<p>注意</p>
<ul>
<li>本地仓库和远程仓库是两个独立的仓库，在本地仓库做的任何修改都不会影响到远程仓库，在远程仓库中做修改也不会影响到本地仓库</li>
<li>因此需要一种机制来同步本地仓库和远程仓库的修改内容，让它们的状态保持一致</li>
</ul>
</li>
<li>
<p><code>git push</code> ：把本地仓库的修改推送给远程仓库</p>
</li>
</ul>
<p><img data-src="git/image-20240819141325292.png" alt="image-20240819141325292"></p>
<p><img data-src="git/image-20240819141258018.png" alt="image-20240819141258018"></p>
<ul>
<li><code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code> ：把远程仓库的修改拉取到本地仓库</li>
</ul>
<p><img data-src="git/image-20240819145404472.png" alt="image-20240819145404472"></p>
<ul>
<li>执行完 <code>git pull</code> ，Git 会自动执行一次合并操作，如果远程仓库中的修改内容和本地仓库中的修改内容没有冲突的话，那么合并操作就会成功，否则合并操作就会因为冲突而失败，此时需要手动解决冲突</li>
<li>从远程仓库获取内容还可以使用 <code>fetch</code>  命令</li>
<li>两者的区别
<ul>
<li><code>fetch</code>  只是获取远程仓库的修改，并不会自动合并到本地仓库中，需要手动合并</li>
</ul>
</li>
</ul>
<h4 id="1013-关联本地仓库和远程仓库"><a class="anchor" href="#1013-关联本地仓库和远程仓库">#</a> 10.1.3 关联本地仓库和远程仓库</h4>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;</span><br><span class="line">git push -u &lt;远程仓库名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>示例</li>
</ul>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:eu8188/first-repo.git</span><br><span class="line">git branch -M master	<span class="comment"># 指定分支的名称为master，可省略</span></span><br><span class="line">git push -u origin master:master  <span class="comment"># 把本地的master分支和远程的origin仓库的master分支关联起来</span></span><br><span class="line"></span><br><span class="line">ps：后面的:master可以省略，因为本地分支的名称和远程分支的名称相同</span><br></pre></td></tr></table></figure></p>
<ul>
<li>执行完再使用 <code>git remote -v</code>  查看
<ul>
<li>可以查看当前仓库所对应的远程仓库的别名和地址</li>
</ul>
</li>
</ul>
<p><img data-src="git/image-20240819142858363.png" alt="image-20240819142858363"></p>
<p><img data-src="git/image-20240819142910300.png" alt="image-20240819142910300"></p>
<ul>
<li>注：Gitee 的操作和 GitHub 基本一致</li>
</ul>
<h3 id="102-gitlab"><a class="anchor" href="#102-gitlab">#</a> 10.2 GitLab</h3>
<ul>
<li>感觉暂时不需要懂，先空着</li>
</ul>
<h2 id="11-gui-工具"><a class="anchor" href="#11-gui-工具">#</a> 11. GUI 工具</h2>
<ul>
<li>GitHub Desktop</li>
<li>SourceTree</li>
<li>GitKraken</li>
<li>VSCode 扩展 GitLens</li>
</ul>
<h2 id="12-在-vscode-中使用-git"><a class="anchor" href="#12-在-vscode-中使用-git">#</a> 12. 在 VSCode 中使用 Git</h2>
<ul>
<li>
<p>ctrl + shift + p：打开命令面板</p>
</li>
<li>
<p>设置 gitbash 为默认终端</p>
<ul>
<li>打开设置搜索： <code>terminal.integrated.profiles.windows</code></li>
<li>添加</li>
</ul>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;git.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\Develop\Git\bin\git.exe&quot;</span></span><br><span class="line"><span class="attr">&quot;terminal.integrated.profiles.windows&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Git Bash&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Git Bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Develop\\Git\\bin\\git.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;terminal.integrated.defaultProfile.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Git Bash&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="git/image-20240819171032514.png" alt="image-20240819171032514"></p>
</li>
</ul>
<p><img data-src="git/image-20240819171056677.png" alt="image-20240819171056677"></p>
<ul>
<li>文件状态</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>??(Untracked)</code></td>
<td>未跟踪</td>
</tr>
<tr>
<td><code>M(Modified)</code></td>
<td>已修改</td>
</tr>
<tr>
<td><code>A(Added)</code></td>
<td>已添加暂存</td>
</tr>
<tr>
<td><code>D(Deleted)</code></td>
<td>已删除</td>
</tr>
<tr>
<td><code>R(Renamed)</code></td>
<td>重命名</td>
</tr>
<tr>
<td><code>U(Updated)</code></td>
<td>已更新未合并</td>
</tr>
</tbody>
</table>
<p><img data-src="git/image-20240819171810766.png" alt="image-20240819171810766"></p>
<h2 id="13-分支"><a class="anchor" href="#13-分支">#</a> 13. 分支</h2>
<blockquote>
<ul>
<li>可以把分支看作是代码库中的不同版本，可以独立存在，并且有自己的提交记录</li>
<li>分支适合团队协作和开发管理，比如多个开发人员可以在自己的分支上进行开发工作，最后再合并到主线代码库中</li>
<li>也可以在一个分支上进行新功能的开发，或者建立一个问题修复的分支来处理一些 bug 和缺陷，这样就可以让主线代码仓库处于一个随时可用的比较稳定的状态，而不会影响到其他功能的开发和测试，保证了项目的正常运行和高效协作</li>
<li>分支的优点就是能够提高团队协作的效率，减少冲突和错误的影响，让团队中的每个人都能够独立开发和测试</li>
</ul>
</blockquote>
<p><img data-src="git/image-20240819173127591.png" alt="image-20240819173127591"></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git branch</code></td>
<td>查看分支列表</td>
</tr>
<tr>
<td><code>git branch branch-name</code></td>
<td>创建分支</td>
</tr>
<tr>
<td><code>git checkout branch-name</code> &lt;br /&gt; <code>git switch branch-name</code></td>
<td>切换分支</td>
</tr>
<tr>
<td><code>git merge branch-name</code></td>
<td>合并分支</td>
</tr>
<tr>
<td><code>git branch -d branch-name</code> 【已合并】&lt;br /&gt; <code>git branch -D branch-name</code> 【未合并】</td>
<td>删除分支</td>
</tr>
<tr>
<td><code>git log --graph --oneline --decorate --all</code></td>
<td>查看分支图</td>
</tr>
</tbody>
</table>
<p><img data-src="git/image-20240820135909011.png" alt="image-20240820135909011"></p>
<h2 id="14-解决合并冲突"><a class="anchor" href="#14-解决合并冲突">#</a> 14. 解决合并冲突</h2>
<blockquote>
<p>如果两个分支修改了同一个文件的同一行代码，Git 就不知道该保留哪个分支的修改内容，也就产生了冲突</p>
</blockquote>
<ul>
<li>手动解决一下冲突，看一下要保留哪个内容</li>
</ul>
<h2 id="15-rebase"><a class="anchor" href="#15-rebase">#</a> 15. rebase</h2>
<ul>
<li>在不同分支上执行 <code>rebase</code>  命令</li>
</ul>
<p><img data-src="git/image-20240820141035186.png" alt="image-20240820141035186"></p>
<ul>
<li>
<p>使用 <code>alias</code>  对命令进行重命名</p>
<ul>
<li>如： <code>alias graph=&quot;git log --oneline --graph --decorate --all&quot;</code></li>
</ul>
</li>
<li>
<p>示例</p>
<ul>
<li>在 dev 分支上</li>
</ul>
<p><img data-src="git/image-20240820142226668.png" alt="image-20240820142226668"></p>
<ul>
<li>在 main 分支上</li>
</ul>
<p><img data-src="git/image-20240820142302991.png" alt="image-20240820142302991"></p>
</li>
<li>
<p>Merge</p>
<ul>
<li>优点：不会破坏原分支的提交历史，方便回溯和查看</li>
<li>缺点：会产生额外的提交节点，分支图比较复杂</li>
</ul>
</li>
<li>
<p>Rebase</p>
<ul>
<li>优点：不会新增额外的提交记录，形成线性历史，比较直观和干净</li>
<li>缺点：会改变提交历史，改变了当前分支 branch out 的节点。需要避免在共享分支使用</li>
</ul>
</li>
<li>
<p>一般来说，如果只是想把两个分支合并起来，不关心提交历史，使用 <code>git merge</code> ；如果确定只有自己在一个分支上开发，并且希望提交历史更加清晰明了，则使用 <code>rebase</code></p>
</li>
</ul>
<h2 id="16-分支管理和工作流模型"><a class="anchor" href="#16-分支管理和工作流模型">#</a> 16. 分支管理和工作流模型</h2>
<ul>
<li>
<p>GitFlow</p>
</li>
<li>
<p>GitHub Flow</p>
</li>
<li>
<p>分支命名</p>
<ul>
<li>推荐使用带有意义的描述性名称来命名分支</li>
<li>版本发布分支 / Tag 示例：v1.0.0</li>
<li>功能分支示例：feature-login-page</li>
<li>修复分支示例：hotfix-#issueid-desc</li>
</ul>
</li>
<li>
<p>分支管理</p>
<ul>
<li>定期合并已经成功验证的分支，及时删除已经合并的分支</li>
<li>保存合适的分支数量</li>
<li>为分支设置合适的管理权限</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/08/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p>
<h2 id="quick-start"><a class="anchor" href="#quick-start">#</a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="anchor" href="#create-a-new-post">#</a> Create a new post</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p>
<h3 id="run-server"><a class="anchor" href="#run-server">#</a> Run server</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p>
<h3 id="generate-static-files"><a class="anchor" href="#generate-static-files">#</a> Generate static files</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p>
<h3 id="deploy-to-remote-sites"><a class="anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span></p>
]]></content>
  </entry>
</search>
